{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cpp": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"using ll = long long;",
			"",
			"using Field = vector<vector<int>>;",
			"using Graph = vector<vector<int>>;",
			"using VI = vector<int>;",
			"using VC = vector<char>;",
			"using PI = pair<int, int>;",
			"",
			"#define REP(i, n) for (int i = 0; i < (n); i++)",
			"#define ALL(x) x.begin(), x.end()",
			"",
			"const long long INF = 1LL<<60;",
			"const int mod = 1000000007;",
			"",
			"template<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }",
			"template<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }",			
			"",
			"int main() {",
			"    cin.tie(0);",
			"    ios_base::sync_with_stdio(false);",
			"    $1",
			"    return 0;",
			"}"
		],
	},
	"comb": {
		"prefix": "comb",
		"body": [
			"const int MAX = 510000;",
			"",
			"ll fac[MAX], finv[MAX], inv[MAX];",
			"",
			"void COMinit() {",
			"    fac[0] = fac[1] = 1;",
			"    finv[0] = finv[1] = 1;",
			"    inv[1] = 1;",
			"    for (int i=2; i<MAX; i++) {",
			"        fac[i] = fac[i-1] * i % mod;",
			"        inv[i] = mod - inv[mod%i] * (mod / i) % mod;",
			"        finv[i] = finv[i - 1] * inv[i] % mod;",
			"    }",
			"}",
			"",
			"ll COM(int n, int k) {",
			"    if(n < k) return 0;",
			"    if (n < 0 || k < 0) return 0;",
			"    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;",
			"}",
			"",
			"ll HCOM(int n, int k) {",
			"    return (n == 0 && k == 0) ? 1 : COM(n+k-1, k);",
			"}",
		]
	},
	"modpow": {
		"prefix": "modpow",
		"body": [
			"ll modpow(ll a, ll n) {",
			"   ll res = 1;",
			"   while (n > 0) {",
			"      if (n & 1) {",
			"         res *= a;",
			"         res %= mod;",
			"      }",
			"      a *= a;",
			"      a %= mod;",
			"",
			"      n >>= 1;",
			"   }",
			"   return res;",
			"}",
		]
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"template <typename T>",
		    "struct SegTree {",
			"   const T INF = numeric_limits<T>::max();",
			"   int n;",
			"   vector<T> dat;",
			"   SegTree(int n_): n(), dat(n_ * 4, 0) {",
			"      int x = 1;",
			"      while (n_ > x) {",
			"         x *= 2;",
			"      }",
			"      n = x;",
			"   }",
		    "",
			"   void update(int i, T x) {",
			"      i += n - 1;",
			"      dat.at(i) = x;",
			"      while (i > 0) {",
			"         i = (i - 1) / 2;",
			"         dat.at(i) = max(dat.at(i * 2 + 1), dat.at(i * 2 + 2));",
			"      }",
			"   }",
			"",
			"   T query(int a, int b) {return query_sub(a, b, 0, 0, n);}",
			"   T query_sub(int a, int b, int k, int l, int r) {",
			"      if (r <= a || b <= l) return 0;",
			"      else if (a <= l && r <= b) return dat.at(k);",
			"      else {",
			"         T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
			"         T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
			"         return max(vl, vr);",
			"      }",
			"   }",
			"};",
		]
	},
	"matrix": {
		"prefix": "matrix",
		"body": [
			"using Matrix = vector<vector<ll>>;",
			"int N;",
			"",
			"Matrix matmul(Matrix &A, Matrix &B) {",
			"   Matrix res(N, vector<ll>(N, 0));",
			"   for (int i = 0; i < N; i++) {",
			"       for (int j = 0; j < N; j++) {",
			"           for (int k = 0; k < N; k++) {",
			"               res.at(i).at(j) = (res.at(i).at(j) + A.at(i).at(k) * B.at(k).at(j)) % mod;",
			"           }",
			"       }",
			"   }",
			"   return res;",
			"}",
			"",
			"Matrix matpow(Matrix M, ll k) {",
			"   Matrix res(N, vector<ll>(N, 0));",
			"   for (int i = 0; i < N; i++) res.at(i).at(i) = 1;",
			"",
			"   while (k > 0) {",
			"       if (k & 1) res = matmul(res, M);",
			"       M = matmul(M, M);",
			"       k >>= 1;",
			"   }",
			"   return res;",
			"}",
		]
	}
}
